{"id":1274850564,"question_id":3436,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1717300647,"status":10,"status_display":"Accepted","runtime":"1091 ms","url":"/submissions/detail/1274850564/","is_pending":"Not Pending","title":"Find Subarray With Bitwise OR Closest to K","memory":"55.8 MB","code":"class Solution {\n    public int minimumDifference(int[] nums, int target) {\n//         int n = nums.length;\n//         int min = Integer.MAX_VALUE;\n\n//         for (int i = 0; i < n; i++) {\n//             int cur = nums[i];\n//             for (int j = i; j < n; j++) {\n//                 cur &= nums[j];\n//                 int diff = Math.abs(k - cur);\n//                 if (diff < min) {\n//                     min = diff;\n//                 }\n//                 if (min == 0) {\n//                     return 0;\n//                 }\n//                 if(cur == 0)\n//                     break;\n//             }\n//         }\n        \n//         int n = nums.length;\n//         int min = Integer.MAX_VALUE;\n//         int cur = -1;\n        \n//         int start = 0;\n//         for (int end = 0; end < n; end++) {\n//             if (cur == -1) {\n//                 cur = nums[end];\n//             } else {\n//                 cur &= nums[end];\n//             }\n            \n//             while (start <= end && cur < k) {\n//                 min = Math.min(min, Math.abs(k - cur));\n//                 if (min == 0) {\n//                     return 0;\n//                 }\n//                 cur &= ~nums[start];\n//                 start++;\n//             }\n            \n//             min = Math.min(min, Math.abs(k - cur));\n//             if (min == 0) {\n//                 return 0;\n//             }\n//         }\n\n        int currentAND = nums[0];\n        int bestDiff = Math.abs(currentAND - target);\n\n        Map<Integer, Integer> windowBitCounts = new HashMap<>();\n        int[] setBits = getSetBits(nums[0]);\n        for (int bit : setBits) {\n            windowBitCounts.put(bit, 1);\n        }\n\n        int left = 0, right = 0;\n        while (right < nums.length) {\n            if (currentAND > target || left > right) {\n                right++;\n                if (right >= nums.length) {\n                    break;\n                }\n                int[] newSetBits = getSetBits(nums[right]);\n                for (int bit : newSetBits) {\n                    windowBitCounts.put(bit, windowBitCounts.getOrDefault(bit, 0) + 1);\n                }\n            } else {\n                for (int bit : getSetBits(nums[left])) {\n                    windowBitCounts.put(bit, windowBitCounts.get(bit) - 1);\n                    if (windowBitCounts.get(bit) == 0) {\n                        windowBitCounts.remove(bit);\n                    }\n                }\n                left++;\n            }\n\n            currentAND = countsToBitwiseAnd(right - left + 1, windowBitCounts);\n\n            if (left <= right) {\n                bestDiff = Math.min(bestDiff, Math.abs(currentAND - target));\n            }\n        }\n\n        return bestDiff;\n    }\n\n    private static int[] getSetBits(int x) {\n        List<Integer> bits = new ArrayList<>();\n        for (int i = 0; x > 0; i++) {\n            if ((x & 1) == 1) {\n                bits.add(i);\n            }\n            x >>= 1;\n        }\n        return bits.stream().mapToInt(i -> i).toArray();\n    }\n\n    private static int countsToBitwiseAnd(int windowLength, Map<Integer, Integer> bitCounts) {\n        int result = 0;\n        for (Map.Entry<Integer, Integer> entry : bitCounts.entrySet()) {\n            if (entry.getValue() == windowLength) {\n                result |= (1 << entry.getKey());\n            }\n        }\n        return result;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-subarray-with-bitwise-or-closest-to-k","has_notes":false,"flag_type":1}