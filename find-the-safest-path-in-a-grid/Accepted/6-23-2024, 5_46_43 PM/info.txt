{"id":1298172040,"question_id":2914,"lang":"java","lang_name":"Java","time":"2 days, 4 hours","timestamp":1719179203,"status":10,"status_display":"Accepted","runtime":"296 ms","url":"/submissions/detail/1298172040/","is_pending":"Not Pending","title":"Find the Safest Path in a Grid","memory":"73.6 MB","code":"class Solution {\n    int[] dx = new int[]{0, 0, 1, -1};\n    int[] dy = new int[]{1, -1, 0, 0};\n\n    class Cell{\n        int x, y;\n        int dist;\n        Cell(int i, int j, int c){\n            x = i;\n            y = j;\n            dist = c;\n        }\n    }\n\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\n        int n = grid.size();\n\n        if(grid.get(0).get(0) == 1 || grid.get(n-1).get(n-1) == 1)\n            return 0;\n        \n        int[][] cost = new int[n][n];\n        for(int[] row: cost)\n            Arrays.fill(row, Integer.MAX_VALUE);\n\n        Queue<int[]> q = new LinkedList<>();\n\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    cost[i][j] = 0;\n                    q.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        while(!q.isEmpty()){\n            int size = q.size();\n\n            while(size-->0){\n                int[] cur = q.poll();\n                int cur_x = cur[0];\n                int cur_y = cur[1];\n                int cur_dist = cost[cur_x][cur_y];\n\n                // if(cost[cur_x][cur_y]<cur_dist)\n                //     continue;\n\n                for(int i=0;i<4;i++){\n                    int new_x = cur_x+dx[i];\n                    int new_y = cur_y+dy[i];\n\n                    if(new_x>=0 && new_y>=0 && new_x<n && new_y<n && cost[new_x][new_y]>cur_dist+1){\n                        cost[new_x][new_y] = cur_dist+1;\n                        q.offer(new int[]{new_x, new_y});\n                    }\n                }\n            }\n        }\n\n        PriorityQueue<Cell> pq = new PriorityQueue<>((a,b) -> b.dist-a.dist);\n        Set<String> visited = new HashSet<>();\n\n        pq.offer(new Cell(0, 0, cost[0][0]));\n        visited.add(0 + \",\" + 0);\n\n        while (!pq.isEmpty()) {\n            Cell cur = pq.poll();\n            int cur_x = cur.x;\n            int cur_y = cur.y;\n            int cur_dist = cur.dist;\n\n            if (cur_x == n-1 && cur_y == n-1) {\n                return cur_dist;\n            }\n\n            for(int i=0;i<4;i++){\n                int new_x = cur_x+dx[i];\n                int new_y = cur_y+dy[i];\n\n                if(new_x>=0 && new_y>=0 && new_x<n && new_y<n && !visited.contains(new_x + \",\" + new_y)){\n                    pq.offer(new Cell(new_x, new_y, Math.min(cur_dist, cost[new_x][new_y])));\n                    visited.add(new_x + \",\" + new_y);\n                }\n            }\n        }\n\n        return -1;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-safest-path-in-a-grid","has_notes":false,"flag_type":1}