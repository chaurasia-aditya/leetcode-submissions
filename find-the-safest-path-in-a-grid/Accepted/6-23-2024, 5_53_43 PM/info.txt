{"id":1298175193,"question_id":2914,"lang":"java","lang_name":"Java","time":"2 days, 4 hours","timestamp":1719179623,"status":10,"status_display":"Accepted","runtime":"90 ms","url":"/submissions/detail/1298175193/","is_pending":"Not Pending","title":"Find the Safest Path in a Grid","memory":"63.1 MB","code":"class Solution {\n    int[] dx = new int[]{0, 0, 1, -1};\n    int[] dy = new int[]{1, -1, 0, 0};\n\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\n        int n = grid.size();\n\n        if(grid.get(0).get(0) == 1 || grid.get(n-1).get(n-1) == 1)\n            return 0;\n        \n        int[][] cost = new int[n][n];\n        for(int[] row: cost)\n            Arrays.fill(row, Integer.MAX_VALUE);\n\n        Queue<int[]> q = new LinkedList<>();\n\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    cost[i][j] = 0;\n                    q.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        while(!q.isEmpty()){\n            int size = q.size();\n\n            while(size-->0){\n                int[] cur = q.poll();\n                int cur_x = cur[0];\n                int cur_y = cur[1];\n                int cur_dist = cost[cur_x][cur_y];\n\n                for(int i=0;i<4;i++){\n                    int new_x = cur_x+dx[i];\n                    int new_y = cur_y+dy[i];\n\n                    if(new_x>=0 && new_y>=0 && new_x<n && new_y<n && cost[new_x][new_y]>cur_dist+1){\n                        cost[new_x][new_y] = cur_dist+1;\n                        q.offer(new int[]{new_x, new_y});\n                    }\n                }\n            }\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[2]-a[2]);\n        boolean[][] visited = new boolean[n][n];\n\n        pq.offer(new int[]{0, 0, cost[0][0]});\n        visited[0][0] = true;\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int cur_x = cur[0];\n            int cur_y = cur[1];\n            int cur_dist = cur[2];\n\n            if (cur_x == n-1 && cur_y == n-1) {\n                return cur_dist;\n            }\n\n            for(int i=0;i<4;i++){\n                int new_x = cur_x+dx[i];\n                int new_y = cur_y+dy[i];\n\n                if(new_x>=0 && new_y>=0 && new_x<n && new_y<n && !visited[new_x][new_y]){\n                    pq.offer(new int[]{new_x, new_y, Math.min(cur_dist, cost[new_x][new_y])});\n                    visited[new_x][new_y] = true;\n                }\n            }\n        }\n\n        return -1;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-safest-path-in-a-grid","has_notes":false,"flag_type":1}