{"id":1171947483,"question_id":3290,"lang":"java","lang_name":"Java","time":"4 months, 2 weeks","timestamp":1707622563,"status":10,"status_display":"Accepted","runtime":"39 ms","url":"/submissions/detail/1171947483/","is_pending":"Not Pending","title":"Number of Subarrays That Match a Pattern II","memory":"183 MB","code":"import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Solution {\n    int KMPSearch(String pat, String txt) \n\t{ \n\t\tint M = pat.length(); \n\t\tint N = txt.length(); \n        \n        int res = 0;\n        \n\t\t// create lps[] that will hold the longest \n\t\t// prefix suffix values for pattern \n\t\tint lps[] = new int[M]; \n\t\tint j = 0; // index for pat[] \n\n\t\t// Preprocess the pattern (calculate lps[] \n\t\t// array) \n\t\tcomputeLPSArray(pat, M, lps); \n\n\t\tint i = 0; // index for txt[] \n\t\twhile (i < N) { \n\t\t\tif (pat.charAt(j) == txt.charAt(i)) { \n\t\t\t\tj++; \n\t\t\t\ti++; \n\t\t\t} \n\t\t\tif (j == M) { \n\t\t\t\t// System.out.println(\"Found pattern \"\n\t\t\t\t// \t\t\t\t+ \"at index \" + (i - j)); \n                res++;\n\t\t\t\tj = lps[j - 1]; \n\t\t\t} \n\n\t\t\t// mismatch after j matches \n\t\t\telse if (i < N && pat.charAt(j) != txt.charAt(i)) { \n\t\t\t\t// Do not match lps[0..lps[j-1]] characters, \n\t\t\t\t// they will match anyway \n\t\t\t\tif (j != 0) \n\t\t\t\t\tj = lps[j - 1]; \n\t\t\t\telse\n\t\t\t\t\ti = i + 1; \n\t\t\t} \n\t\t} \n        return res;\n\t} \n\n\tvoid computeLPSArray(String pat, int M, int lps[]) \n\t{ \n\t\t// length of the previous longest prefix suffix \n\t\tint len = 0; \n\t\tint i = 1; \n\t\tlps[0] = 0; // lps[0] is always 0 \n\n\t\t// the loop calculates lps[i] for i = 1 to M-1 \n\t\twhile (i < M) { \n\t\t\tif (pat.charAt(i) == pat.charAt(len)) { \n\t\t\t\tlen++; \n\t\t\t\tlps[i] = len; \n\t\t\t\ti++; \n\t\t\t} \n\t\t\telse // (pat[i] != pat[len]) \n\t\t\t{ \n\t\t\t\t// This is tricky. Consider the example. \n\t\t\t\t// AAACAAAA and i = 7. The idea is similar \n\t\t\t\t// to search step. \n\t\t\t\tif (len != 0) { \n\t\t\t\t\tlen = lps[len - 1]; \n\n\t\t\t\t\t// Also, note that we do not increment \n\t\t\t\t\t// i here \n\t\t\t\t} \n\t\t\t\telse // if (len == 0) \n\t\t\t\t{ \n\t\t\t\t\tlps[i] = len; \n\t\t\t\t\ti++; \n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t} \n    \n    public int countMatchingSubarrays(int[] nums, int[] pattern) {\n\n        StringBuilder s = new StringBuilder();\n        StringBuilder p = new StringBuilder();\n        \n        for(int i=0;i<nums.length-1;i++){\n            if(nums[i]<nums[i+1]){\n                nums[i] = 1;\n            }else if(nums[i]>nums[i+1]){\n                nums[i] = 2;\n            }else{\n                nums[i] = 0;\n            }\n            s.append(nums[i]);\n        }\n        s.append(9);\n        \n        int res = 0;\n        \n        for(int i=0;i<pattern.length;i++){\n            if(pattern[i] == -1)\n                pattern[i] = 2;\n            p.append(pattern[i]);\n        \n        }\n        \n        String str = s.toString();\n        String pat = p.toString(); \n        \n//         System.out.println(str);\n        // System.out.println(pat);\n        \n        res = KMPSearch(pat, str);\n        // System.out.println();\n        \n//         Pattern pat = Pattern.compile(p.toString());\n//         Matcher mat = pat.matcher(str);\n        \n//         int i = 0;\n//         while (mat.find(i)) {\n//             res++;\n//             i = mat.start() + 1;\n//         }\n        \n        \n        \n//         int lastIndex = 0;\n        \n//         while (lastIndex != -1 && lastIndex+pat.length()!=str.length()) {\n            \n//             lastIndex = str.indexOf(pat, lastIndex);\n\n//             if (lastIndex != -1 && lastIndex+pat.length()!=str.length()) {\n//                 res++;\n//                 lastIndex++;\n//             }\n//         }\n        \n        return res;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-subarrays-that-match-a-pattern-ii","has_notes":false,"flag_type":1}